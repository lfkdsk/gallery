<!-- @format -->



<!DOCTYPE html>
<html lang="zh-CN">
<!-- Head tag -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <!--360 使用 Google Chrome Frame-->
  <meta name="renderer" content="webkit">
  <!--百度禁止转码-->
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <!--Description-->
  
  <meta name="description" content="拿起相机，认真思考">
  
  <meta name="google-site-verification" content="J4gssmXGNI9-DfJ9w52mL5KFPlRCYvySveEN0RJFZHU" />
  <!--Author-->
  
  <meta name="author" content="lfkdsk">
  
  <!--Open Graph Title-->
  <meta property="og:title" content="GridLanes" />
  <!--Open Graph Description-->
  <meta property="og:description" content="拿起相机，认真思考" />
  <!--Open Graph Site Name-->
  <meta property="og:site_name" content="照片集" />
  <!--Type page-->
  
  <meta property="og:type" content="article" />
  
  <!--Page Cover-->
  
  <meta property="og:image" content="https://github.com/lfkdsk/picx-images-hosting/raw/master/20230817/IMG_7586.4e91my1ve140.17iz0sa56gik.webp" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- Title -->
  
  <title>GridLanes - 照片集</title>
  <!-- 添加到主屏后的标题（iOS 6 新增） -->
  <meta name="apple-mobile-web-app-title" content="照片集">
  <!-- 是否启用 WebApp 全屏模式 -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <link rel="apple-touch-startup-image" href="/assets/ splash-assets.png" media="(max-device-width: 700px)">
  <!-- 禁止数字识自动别为电话号码 -->
  <meta name="format-detection" content="telephone=no" />
  <link rel="shortcut icon" href="https://imgur.lzmun.com/picgo/after2022/tripper2whitefull.png_avatar">
  <!--Apple iOS Safari ICON-->
  <link rel="apple-touch-icon" sizes="57x57" href="https://imgur.lzmun.com/picgo/after2022/tripper2color.png_iPhone" />
  <link rel="apple-touch-icon" sizes="72x72" href="https://imgur.lzmun.com/picgo/after2022/tripper2color.png_RetinaiPad" />
  <link rel="apple-touch-icon" sizes="114x114" href="https://imgur.lzmun.com/picgo/after2022/tripper2color.png_iPhoneHD" />
  <link rel="apple-touch-icon" sizes="144x144" href="https://imgur.lzmun.com/picgo/after2022/tripper2color.png_RetinaiPad" />
  <!-- 添加 RSS 订阅 -->
  <link rel="alternate" type="application/rss+xml" title="照片集" href="/rss" />
  <!-- uc强制竖屏 -->
  <meta name="screen-orientation" content="portrait">
  <!-- QQ强制竖屏 -->
  <meta name="x5-orientation" content="portrait">
  <!-- UC强制全屏 -->
  <meta name="full-screen" content="yes">
  <!-- QQ强制全屏 -->
  <meta name="x5-fullscreen" content="true">
  <!-- UC应用模式 -->
  <meta name="browsermode" content="application">
  <!-- QQ应用模式 -->
  <meta name="x5-page-mode" content="app">
  <!-- https://material.io/resources/icons/?style=outline -->
  
  
  <script src="https://lf1-cdn-tos.bytegoofy.com/obj/iconpark/icons_29703_16.0f9623ad85e64efb07f6dddba36807a6.js"></script>
  
  
<style>
  .itp-gallery-title,
  .itp-gallery-subtitle,
  .itp-post-title,
  .itp-post-entry-title,
  .itp-post-entry-subtitle,
  .itp-mag-logo,
  .itp-index-title,
  .itp-post-entry-moment,
  .itp-header-actions-menu {
    font-family: ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Noto Sans,Ubuntu,Cantarell,Helvetica Neue,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Noto Sans,Ubuntu,Cantarell,Helvetica Neue,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;
  }

  .itp-header-title,
  .itp-m3-post-entry-info .title,
  .itp-header-actions,
  .itp-cover-title,
  .itp-cover-subtitle,
  .itp-post-subtitle,
  .itp-post-entry-title,
  .itp-m3-cover-subtitle,
  .itp-m3-cover-title,
  .itp-gallery-info .title,
  .footer-info {
    font-family: ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Noto Sans,Ubuntu,Cantarell,Helvetica Neue,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Noto Sans,Ubuntu,Cantarell,Helvetica Neue,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;
  }

  .article,
  .itp-post-entry-excerpt {
    font-family: 'SF UI Display', '.PingFang SC', 'PingFang SC', 'Neue Haas Grotesk Text Pro', 'Arial Nova', 'Segoe UI', 'Microsoft YaHei', 'Microsoft JhengHei', 'Helvetica Neue', 'Source Han Sans SC', 'Noto Sans CJK SC', 'Source Han Sans CN', 'Noto Sans SC', 'Source Han Sans TC', 'Noto Sans CJK TC', 'Helvetica', 'Hiragino Sans GB', sans-serif;
  }
</style>

  <!-- Custom CSS/Sass -->
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/fancybox.css">

  <!--样式切换-->
  
  
<link rel="stylesheet" href="/css/material3.css">

  
  
  
  
  
  <!--highlight.js CSS-->
  
  
<link rel="stylesheet" href="/css/highlight/github.css">

  
  

  

  <!-- jquery -->
  
  <script src="/js/jquery.min.js"></script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css"/>
  <!--Comment-->
  
  <!--Vercel Audiences Analytics-->
  
  <!--umami analytics-->
  
  <script src="js/tools.js"></script>
  <!--Howxm Analytics-->
  
  
  
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-8TMSDJG47Q" defer></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'G-8TMSDJG47Q');
  </script>
  
  
  
  
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#71afdd">
  
  <!-- Google Search Advanced
  https://developers.google.com/search/docs/advanced/structured-data/search-gallery
  -->
  
  
  
  
  
  <!--<script src="https://cdn.tailwindcss.com"></script>
<script>
  tailwind.config = {
    theme: {
      spacing: {
        '1': '8px',
        '2': '12px',
        '3': '16px',
        '4': '24px',
        '5': '32px',
        '6': '48px',
      },
      container: {
        center: true,
      },
      extend: {
        colors: {
          tblack: '#222831',
        },
        boxShadow: {
          'itp': '1px 10px 30px 0 rgb(0 0 0 / 10%)',
        }
      }
    }
  }
</script>-->

<link rel="stylesheet" href="/css/tailwind.css">

<meta name="generator" content="Hexo 6.0.0"></head>



<!--Other Pages-->


<body>
  <!-- Nav -->
  


<div class="itp-float-bar">
  <!--所有页面都显示-->
  <a class="itp-float-bar-item rounded" href="/" title="照片集">
    
    <iconpark-icon class="navicon" name="home"></iconpark-icon>
    
  </a>
  
  <!--只在 **非文章** 页面显示-->
  
  <a class="itp-float-bar-item rounded" href="/location" title="地图">
    
    <iconpark-icon class="navicon" name="local-two"></iconpark-icon>
    
  </a>
  
  <a class="itp-float-bar-item rounded" target="_blank" rel="noopener" href="https://lfkdsk.github.io/blog" title="归档">
    
    <iconpark-icon class="navicon" name="inbox"></iconpark-icon>
    
  </a>
  
  <a class="itp-float-bar-item rounded" href="/grid-all" title="时间线">
    
    <iconpark-icon class="navicon" name="grid-nine"></iconpark-icon>
    
  </a>
  
  <a class="itp-float-bar-item rounded" href="/status" title="状态监控">
    
    <iconpark-icon class="navicon" name="list-view"></iconpark-icon>
    
  </a>
  
  <a class="itp-float-bar-item rounded" href="/random" title="随机">
    
    <iconpark-icon class="navicon" name="pic"></iconpark-icon>
    
  </a>
  
  
  

  <div class="itp-float-layer itp-toc-layer">
    <div class="clost-btn" style="display: flex;">
      <a class="itp-float-layer-close-btn" id="close_btn">
        <div class="close_btn_red">
        </div>
      </a>
    </div>
    
  </div>
  <div class="itp-float-layer-bg layer-bg-nodisplay" id="close_layer"></div>
</div>


<style>
  .navicon {
    font-size: 18px;
    padding-top: 18px;
    color: var(--main-black);
  }
</style>
  <!-- Main Content -->
  <script src="js/sql-wasm.js"></script>

<section class="pjax-area">
    <div id="grid-all" class="content-area album-area">
        <div id="floating-date" class="floating-date"></div>
        <div id="masonry" class="gpro-masonry grid grid-cols-2 xs:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-7"></div>
    </div>
    <div id="sentinel" style="height: 1px; opacity: 0;"></div>
    <script type="module">
        const SQL = await initSqlJs({
            locateFile: (file) => `/js/sql-wasm.wasm`,
        });
        const sqlite = await fetch("sqlite.db");
        const sqlite_buf = await sqlite.arrayBuffer();
        const db = new SQL.Database(new Uint8Array(sqlite_buf));
        const start = performance.now();
        const album = getParam('album');
        var filter = getParam('filter');
        const maker = getParam('maker');
        const lens_model = getParam('lens_model');
        const country = getParam('country');
        const focal_length = getParam('focal_length');
        var loadAll = getParam('all') !== null;
        var page = 1;
        var pageSize = 40;
        var historyToday = false;
        const sentinel = document.getElementById("sentinel");
        const masonry = document.getElementById("masonry");
        const floatingDate = document.getElementById("floating-date");
        const PLACEHOLDER_IMG = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
        let hasMore = true;
        let isFetching = false;
        let floatingDateRaf = 0;
        const visibleItems = new Set();
        const loadedPhotos = [];
        const photoIndexByPath = new Map();
        let viewer = null;
        let viewerIndex = -1;
        let viewerRenderSeq = 0;
        let viewerZoom = { scale: 1, tx: 0, ty: 0, panning: false, px: 0, py: 0, baseTx: 0, baseTy: 0 };
        if (filter !== null) {
            loadAll = true;
        }
        if (filter === "historytoday") {
            historyToday = true;
            filter = new Date().toISOString().split('T')[0];
        }
        function sqlString(value) {
            return "'" + String(value).replace(/'/g, "''") + "'";
        }
        function scheduleFloatingDateUpdate() {
            if (floatingDateRaf) return;
            floatingDateRaf = requestAnimationFrame(updateFloatingDate);
        }
        function updateFloatingDate() {
            floatingDateRaf = 0;
            if (!visibleItems.size) return;
            let best = null;
            let bestTop = Infinity;
            for (const el of visibleItems) {
                const top = el.getBoundingClientRect().top;
                if (top >= -20 && top < bestTop) {
                    bestTop = top;
                    best = el;
                }
            }
            if (!best) {
                let maxTop = -Infinity;
                for (const el of visibleItems) {
                    const top = el.getBoundingClientRect().top;
                    if (top > maxTop) {
                        maxTop = top;
                        best = el;
                    }
                }
            }
            const date = best?.getAttribute("data-date");
            if (!date) return;
            floatingDate.textContent = date === "###" ? "Unknown" : date;
            if (!floatingDate.classList.contains("show")) {
                floatingDate.classList.add("show");
            }
        }
        const itemObserver = new IntersectionObserver(
            (entries) => {
                for (const entry of entries) {
                    if (entry.isIntersecting) {
                        visibleItems.add(entry.target);
                    } else {
                        visibleItems.delete(entry.target);
                    }
                }
                scheduleFloatingDateUpdate();
            },
            { root: null, threshold: 0 }
        );

        const DEFAULT_ASPECT_RATIO = 2 / 3;

        function getMasonryMetrics() {
            const styles = getComputedStyle(masonry);
            const rowHeight = parseFloat(styles.getPropertyValue("grid-auto-rows")) || 1;
            const rowGap = parseFloat(styles.getPropertyValue("gap")) || 0;
            return { rowHeight, rowGap };
        }

        function calcSpan(height, rowHeight, rowGap) {
            return Math.max(1, Math.ceil((height + rowGap) / (rowHeight + rowGap)));
        }

        function getItemAspectRatio(item) {
            const img = item.querySelector("img");
            if (img && img.naturalWidth > 0 && img.naturalHeight > 0) {
                return img.naturalHeight / img.naturalWidth;
            }
            return DEFAULT_ASPECT_RATIO;
        }

        function resizeMasonryItem(item) {
            const { rowHeight, rowGap } = getMasonryMetrics();
            const width = item.getBoundingClientRect().width;
            if (!width) return;
            const ratio = getItemAspectRatio(item);
            const height = width * ratio;
            item.style.gridRowEnd = `span ${calcSpan(height, rowHeight, rowGap)}`;
        }

        function resizeAllMasonryItems() {
            for (const item of masonry.querySelectorAll(".gpro-item")) {
                resizeMasonryItem(item);
            }
            scheduleFloatingDateUpdate();
        }

        function normalizeNumberString(v) {
            if (v === null || v === undefined) return '';
            const s = String(v).trim();
            if (!s) return '';
            const num = Number(s);
            if (isFinite(num)) {
                const fixed = Math.round(num * 10) / 10;
                return String(fixed);
            }
            return s;
        }

        function createIconSvg(type) {
            const svgNS = 'http://www.w3.org/2000/svg';
            const svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('aria-hidden', 'true');
            svg.setAttribute('focusable', 'false');

            const add = (el) => {
                svg.appendChild(el);
                return el;
            };
            const circle = (cx, cy, r) => {
                const c = document.createElementNS(svgNS, 'circle');
                c.setAttribute('cx', String(cx));
                c.setAttribute('cy', String(cy));
                c.setAttribute('r', String(r));
                return add(c);
            };
            const line = (x1, y1, x2, y2) => {
                const l = document.createElementNS(svgNS, 'line');
                l.setAttribute('x1', String(x1));
                l.setAttribute('y1', String(y1));
                l.setAttribute('x2', String(x2));
                l.setAttribute('y2', String(y2));
                return add(l);
            };
            const path = (d) => {
                const p = document.createElementNS(svgNS, 'path');
                p.setAttribute('d', d);
                return add(p);
            };
            const rect = (x, y, w, h, rx = 0) => {
                const r = document.createElementNS(svgNS, 'rect');
                r.setAttribute('x', String(x));
                r.setAttribute('y', String(y));
                r.setAttribute('width', String(w));
                r.setAttribute('height', String(h));
                if (rx) r.setAttribute('rx', String(rx));
                return add(r);
            };
            const text = (value, x, y) => {
                const t = document.createElementNS(svgNS, 'text');
                t.setAttribute('x', String(x));
                t.setAttribute('y', String(y));
                t.textContent = value;
                return add(t);
            };

            if (type === 'focal') {
                circle(12, 12, 7);
                circle(12, 12, 2);
                line(12, 4, 12, 7);
                line(12, 17, 12, 20);
                line(4, 12, 7, 12);
                line(17, 12, 20, 12);
            } else if (type === 'aperture') {
                circle(12, 12, 8);
                path('M12 4 L16 10 L12 20 L8 14 Z');
                path('M12 4 L8 10 L12 20 L16 14 Z');
            } else if (type === 'shutter') {
                circle(12, 13, 7);
                line(12, 6, 12, 3.8);
                line(9, 3.8, 15, 3.8);
                line(12, 13, 12, 9);
                line(12, 13, 15, 14.8);
            } else if (type === 'iso') {
                rect(5, 6, 14, 12, 3);
                const t = text('ISO', 12, 14.2);
                t.setAttribute('text-anchor', 'middle');
                t.setAttribute('dominant-baseline', 'middle');
            }

            return svg;
        }

        function buildExifChips(exif) {
            const chips = [];
            const focal = normalizeNumberString(exif?.focal_length);
            if (focal) chips.push({ type: 'focal', label: `${focal}mm` });
            const fnum = normalizeNumberString(exif?.f_number);
            if (fnum) chips.push({ type: 'aperture', label: `f/${fnum}` });
            const exp = (exif?.exposure_time || '').toString().trim();
            if (exp) chips.push({ type: 'shutter', label: exp.endsWith('s') ? exp : `${exp}s` });
            const iso = normalizeNumberString(exif?.iso);
            if (iso) chips.push({ type: 'iso', label: `ISO ${iso}` });
            return chips;
        }

        function upsertPhoto(photo) {
            const existing = photoIndexByPath.get(photo.path);
            if (existing !== undefined) {
                loadedPhotos[existing] = photo;
                photo._idx = existing;
                return existing;
            }
            const idx = loadedPhotos.length;
            loadedPhotos.push(photo);
            photoIndexByPath.set(photo.path, idx);
            photo._idx = idx;
            return idx;
        }

        function clamp(n, min, max) {
            return Math.min(max, Math.max(min, n));
        }

        function formatDateTime(dt) {
            const s = (dt || '').toString().trim();
            if (!s) return '';
            return s.replace('T', ' ').replace('Z', '');
        }

        function formatBytes(bytes) {
            const b = Number(bytes);
            if (!Number.isFinite(b) || b <= 0) return '';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let idx = 0;
            let v = b;
            while (v >= 1024 && idx < units.length - 1) {
                v /= 1024;
                idx += 1;
            }
            const digits = idx === 0 ? 0 : v >= 100 ? 0 : v >= 10 ? 1 : 2;
            return `${v.toFixed(digits)}${units[idx]}`;
        }

        function formatMp(w, h) {
            const ww = Number(w);
            const hh = Number(h);
            if (!Number.isFinite(ww) || !Number.isFinite(hh) || ww <= 0 || hh <= 0) return '';
            const mp = (ww * hh) / 1000000;
            const digits = mp >= 10 ? 0 : 1;
            return `${mp.toFixed(digits)} MP`;
        }

        function formatUtcOffset() {
            const offsetMin = -new Date().getTimezoneOffset();
            const sign = offsetMin >= 0 ? '+' : '-';
            const abs = Math.abs(offsetMin);
            const hh = Math.floor(abs / 60);
            const mm = abs % 60;
            if (!mm) return `UTC${sign}${hh}`;
            return `UTC${sign}${hh}:${String(mm).padStart(2, '0')}`;
        }

        function parseJpegExif(buf) {
            const dv = new DataView(buf);
            const len = dv.byteLength;
            if (len < 4 || dv.getUint16(0, false) !== 0xffd8) return null;

            let offset = 2;
            while (offset + 4 <= len) {
                if (dv.getUint8(offset) !== 0xff) break;
                const marker = dv.getUint8(offset + 1);
                if (marker === 0xd9 || marker === 0xda) break;
                const size = dv.getUint16(offset + 2, false);
                if (size < 2) break;

                if (marker === 0xe1 && offset + 2 + size <= len) {
                    const start = offset + 4;
                    if (start + 6 <= len) {
                        const exifId = String.fromCharCode(
                            dv.getUint8(start),
                            dv.getUint8(start + 1),
                            dv.getUint8(start + 2),
                            dv.getUint8(start + 3)
                        );
                        if (exifId === 'Exif' && dv.getUint16(start + 4, false) === 0x0000) {
                            const tiffStart = start + 6;
                            const endian = dv.getUint16(tiffStart, false);
                            const le = endian === 0x4949;
                            if (!le && endian !== 0x4d4d) return null;
                            const readU16 = (p) => dv.getUint16(p, le);
                            const readU32 = (p) => dv.getUint32(p, le);
                            const readI32 = (p) => dv.getInt32(p, le);

                            if (readU16(tiffStart + 2) !== 0x002a) return null;
                            const ifd0Off = readU32(tiffStart + 4);

                            const typeSize = (t) => {
                                if (t === 1 || t === 2 || t === 7) return 1;
                                if (t === 3) return 2;
                                if (t === 4 || t === 9) return 4;
                                if (t === 5 || t === 10) return 8;
                                return 0;
                            };

                            const readAscii = (p, count) => {
                                const end = Math.min(len, p + count);
                                let s = '';
                                for (let i = p; i < end; i++) {
                                    const c = dv.getUint8(i);
                                    if (c === 0) break;
                                    s += String.fromCharCode(c);
                                }
                                return s.trim();
                            };

                            const readRational = (p, signed) => {
                                const a = signed ? readI32(p) : readU32(p);
                                const b = signed ? readI32(p + 4) : readU32(p + 4);
                                if (!b) return 0;
                                return a / b;
                            };

                            const readValue = (t, count, valuePtr) => {
                                const sz = typeSize(t) * count;
                                const p = sz <= 4 ? valuePtr : tiffStart + readU32(valuePtr);
                                if (t === 2) return readAscii(p, count);
                                if (t === 3) {
                                    if (count === 1) return readU16(p);
                                    const arr = [];
                                    for (let i = 0; i < count; i++) arr.push(readU16(p + i * 2));
                                    return arr;
                                }
                                if (t === 4) {
                                    if (count === 1) return readU32(p);
                                    const arr = [];
                                    for (let i = 0; i < count; i++) arr.push(readU32(p + i * 4));
                                    return arr;
                                }
                                if (t === 5) {
                                    if (count === 1) return readRational(p, false);
                                    const arr = [];
                                    for (let i = 0; i < count; i++) arr.push(readRational(p + i * 8, false));
                                    return arr;
                                }
                                if (t === 9) {
                                    if (count === 1) return readI32(p);
                                    const arr = [];
                                    for (let i = 0; i < count; i++) arr.push(readI32(p + i * 4));
                                    return arr;
                                }
                                if (t === 10) {
                                    if (count === 1) return readRational(p, true);
                                    const arr = [];
                                    for (let i = 0; i < count; i++) arr.push(readRational(p + i * 8, true));
                                    return arr;
                                }
                                return null;
                            };

                            const readIfd = (ifdOffset) => {
                                const base = tiffStart + ifdOffset;
                                if (base + 2 > len) return null;
                                const count = readU16(base);
                                const entriesBase = base + 2;
                                const entriesEnd = entriesBase + count * 12;
                                if (entriesEnd + 4 > len) return null;
                                const tags = new Map();
                                for (let i = 0; i < count; i++) {
                                    const ep = entriesBase + i * 12;
                                    const tag = readU16(ep);
                                    const type = readU16(ep + 2);
                                    const n = readU32(ep + 4);
                                    const val = readValue(type, n, ep + 8);
                                    tags.set(tag, val);
                                }
                                const next = readU32(entriesEnd);
                                return { tags, next };
                            };

                            const ifd0 = readIfd(ifd0Off);
                            if (!ifd0) return null;
                            const exifIfdPtr = ifd0.tags.get(0x8769);
                            const gpsIfdPtr = ifd0.tags.get(0x8825);
                            const exifIfd = typeof exifIfdPtr === 'number' ? readIfd(exifIfdPtr) : null;
                            const gpsIfd = typeof gpsIfdPtr === 'number' ? readIfd(gpsIfdPtr) : null;

                            const exif = {
                                software: ifd0.tags.get(0x0131) || '',
                                colorSpace: exifIfd?.tags.get(0xa001) ?? null,
                                exposureProgram: exifIfd?.tags.get(0x8822) ?? null,
                                exposureMode: exifIfd?.tags.get(0xa402) ?? null,
                                meteringMode: exifIfd?.tags.get(0x9207) ?? null,
                                whiteBalance: exifIfd?.tags.get(0xa403) ?? null,
                                flash: exifIfd?.tags.get(0x9209) ?? null,
                                lightSource: exifIfd?.tags.get(0x9208) ?? null,
                                sensingMethod: exifIfd?.tags.get(0xa217) ?? null,
                                sceneCaptureType: exifIfd?.tags.get(0xa406) ?? null,
                                exposureBiasValue: exifIfd?.tags.get(0x9204) ?? null,
                                brightnessValue: exifIfd?.tags.get(0x9203) ?? null,
                                shutterSpeedValue: exifIfd?.tags.get(0x9201) ?? null,
                                apertureValue: exifIfd?.tags.get(0x9202) ?? null,
                                focalLength35mm: exifIfd?.tags.get(0xa405) ?? null,
                                maxApertureValue: exifIfd?.tags.get(0x9205) ?? null,
                                gpsLatRef: gpsIfd?.tags.get(0x0001) || '',
                                gpsLat: gpsIfd?.tags.get(0x0002) || null,
                                gpsLonRef: gpsIfd?.tags.get(0x0003) || '',
                                gpsLon: gpsIfd?.tags.get(0x0004) || null,
                                gpsAltRef: gpsIfd?.tags.get(0x0005) ?? null,
                                gpsAlt: gpsIfd?.tags.get(0x0006) ?? null,
                            };

                            const toDeg = (arr) => {
                                if (!Array.isArray(arr) || arr.length < 3) return null;
                                const d = Number(arr[0]);
                                const m = Number(arr[1]);
                                const s = Number(arr[2]);
                                if (!Number.isFinite(d) || !Number.isFinite(m) || !Number.isFinite(s)) return null;
                                return d + m / 60 + s / 3600;
                            };

                            if (exif.gpsLat) {
                                const v = toDeg(exif.gpsLat);
                                if (v !== null) exif.gpsLat = (String(exif.gpsLatRef).toUpperCase() === 'S' ? -v : v);
                            }
                            if (exif.gpsLon) {
                                const v = toDeg(exif.gpsLon);
                                if (v !== null) exif.gpsLon = (String(exif.gpsLonRef).toUpperCase() === 'W' ? -v : v);
                            }
                            if (typeof exif.gpsAlt === 'number' && exif.gpsAltRef === 1) {
                                exif.gpsAlt = -exif.gpsAlt;
                            }

                            return exif;
                        }
                    }
                }
                offset += 2 + size;
            }
            return null;
        }

        function calculateHistogram(imageData) {
            const histogram = {
                red: Array.from({ length: 256 }).fill(0),
                green: Array.from({ length: 256 }).fill(0),
                blue: Array.from({ length: 256 }).fill(0),
                luminance: Array.from({ length: 256 }).fill(0),
            };

            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                histogram.red[r]++;
                histogram.green[g]++;
                histogram.blue[b]++;
                const lum = Math.round(0.2126 * r + 0.7152 * g + 0.0722 * b);
                histogram.luminance[lum]++;
            }

            const compress = (channelData) => {
                const compressed = Array.from({ length: 128 }).fill(0);
                for (let i = 0; i < 256; i++) {
                    compressed[Math.floor(i / 2)] += channelData[i];
                }
                return compressed;
            };

            return {
                full: histogram,
                compressed: {
                    red: compress(histogram.red),
                    green: compress(histogram.green),
                    blue: compress(histogram.blue),
                    luminance: compress(histogram.luminance),
                },
            };
        }

        function drawHistogram(canvas, histogram) {
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            const rect = canvas.getBoundingClientRect();
            const width = rect.width || canvas.clientWidth || 0;
            const height = rect.height || canvas.clientHeight || 0;
            if (!width || !height) return;
            const dpr = window.devicePixelRatio || 1;

            canvas.width = Math.round(width * dpr);
            canvas.height = Math.round(height * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;

            ctx.clearRect(0, 0, width, height);

            const maxVal = Math.max(...histogram.luminance, ...histogram.red, ...histogram.green, ...histogram.blue);
            if (!maxVal) return;

            const padding = 0;
            const chartWidth = width - padding * 2;
            const chartHeight = height - padding * 2;

            const colors = {
                red: 'rgb(255, 105, 97)',
                green: 'rgb(52, 199, 89)',
                blue: 'rgb(64, 156, 255)',
                luminance: 'rgba(255, 255, 255, 0.6)',
                background: 'rgba(28, 28, 30, 0.95)',
                grid: 'rgba(255, 255, 255, 0.04)',
                border: 'rgba(255, 255, 255, 0.08)',
            };

            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = colors.grid;
            ctx.lineWidth = 0.5;
            for (let i = 1; i <= 3; i++) {
                const y = padding + (chartHeight / 4) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            const drawBars = (data, color, alpha) => {
                const barWidth = chartWidth / data.length;
                for (let i = 0; i < data.length; i++) {
                    const datum = data[i];
                    const barHeight = (datum / maxVal) * chartHeight;
                    const x = padding + i * barWidth;
                    const y = height - padding - barHeight;

                    const gradient = ctx.createLinearGradient(0, y, 0, height - padding);

                    let topColor;
                    let bottomColor;
                    if (String(color).startsWith('rgba')) {
                        topColor = String(color).replace(/[\d.]+\)$/, `${alpha})`);
                        bottomColor = String(color).replace(/[\d.]+\)$/, `${alpha * 0.1})`);
                    } else if (String(color).startsWith('rgb')) {
                        topColor = String(color).replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                        bottomColor = String(color).replace('rgb', 'rgba').replace(')', `, ${alpha * 0.1})`);
                    } else {
                        topColor = String(color);
                        bottomColor = String(color);
                    }

                    gradient.addColorStop(0, topColor);
                    gradient.addColorStop(1, bottomColor);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, barWidth * 0.8, barHeight);
                }
            };

            drawBars(histogram.luminance, colors.luminance, 0.3);
            ctx.globalCompositeOperation = 'screen';
            drawBars(histogram.red, colors.red, 0.7);
            drawBars(histogram.green, colors.green, 0.7);
            drawBars(histogram.blue, colors.blue, 0.7);
            ctx.globalCompositeOperation = 'source-over';

            ctx.strokeStyle = colors.border;
            ctx.lineWidth = 1;
            ctx.strokeRect(padding - 0.5, padding - 0.5, chartWidth + 1, chartHeight + 1);

            const highlightGradient = ctx.createLinearGradient(0, 0, 0, height * 0.2);
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.03)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = highlightGradient;
            ctx.fillRect(0, 0, width, height * 0.2);
        }

        function calculateHistogramAndToneFromImage(imgEl) {
            const w = imgEl.naturalWidth;
            const h = imgEl.naturalHeight;
            if (!w || !h) return null;

            const maxSize = 300;
            const scale = Math.min(maxSize / w, maxSize / h, 1);
            const sw = Math.max(1, Math.floor(w * scale));
            const sh = Math.max(1, Math.floor(h * scale));
            const canvas = document.createElement('canvas');
            canvas.width = sw;
            canvas.height = sh;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            if (!ctx) return null;
            ctx.drawImage(imgEl, 0, 0, sw, sh);

            let imageData;
            try {
                imageData = ctx.getImageData(0, 0, sw, sh);
            } catch (_) {
                return null;
            }

            const { full, compressed } = calculateHistogram(imageData);
            const pixelCount = sw * sh;
            if (!pixelCount) return null;

            const lum = full.luminance.map((v) => v / pixelCount);

            let totalLuminance = 0;
            let totalPixels = 0;
            for (let i = 0; i < 256; i++) {
                totalLuminance += i * lum[i];
                totalPixels += lum[i];
            }
            const mean = totalPixels ? totalLuminance / totalPixels : 0;
            const brightness = Math.round(mean * (100 / 255));

            let shadowRatio = 0;
            let highlightRatio = 0;
            for (let i = 0; i < 86; i++) shadowRatio += lum[i];
            for (let i = 170; i < 256; i++) highlightRatio += lum[i];

            let variance = 0;
            for (let i = 0; i < 256; i++) {
                variance += lum[i] * Math.pow(i - mean, 2);
            }
            const stdDev = Math.sqrt(variance);
            const contrast = Math.min(100, Math.round((stdDev / 127.5) * 100));

            let toneType = 'normal';
            if (brightness < 30 && shadowRatio > 0.6) toneType = 'low-key';
            else if (brightness > 70 && highlightRatio > 0.6) toneType = 'high-key';
            else if (contrast > 60 && shadowRatio > 0.3 && highlightRatio > 0.3) toneType = 'high-contrast';

            return {
                histogram: compressed,
                tone: {
                    toneType,
                    brightness,
                    contrast,
                    shadowRatio: Math.round(shadowRatio * 100) / 100,
                    highlightRatio: Math.round(highlightRatio * 100) / 100,
                },
            };
        }

        function getExt(path) {
            const m = /\.([a-zA-Z0-9]+)$/.exec(path || '');
            return (m ? m[1] : '').toUpperCase();
        }

        function ensureViewer() {
            if (viewer) return viewer;
            const root = document.createElement('div');
            root.id = 'glv';
            root.className = 'glv';
            root.hidden = true;

            const backdrop = document.createElement('div');
            backdrop.className = 'glv-backdrop';
            root.appendChild(backdrop);

            const shell = document.createElement('div');
            shell.className = 'glv-shell';
            root.appendChild(shell);

            const main = document.createElement('div');
            main.className = 'glv-main';
            shell.appendChild(main);

            const topbar = document.createElement('div');
            topbar.className = 'glv-topbar';
            main.appendChild(topbar);

            const btnClose = document.createElement('button');
            btnClose.className = 'glv-btn glv-close';
            btnClose.type = 'button';
            btnClose.textContent = '×';
            topbar.appendChild(btnClose);

            const btnZoom = document.createElement('button');
            btnZoom.className = 'glv-btn glv-zoom';
            btnZoom.type = 'button';
            btnZoom.textContent = '1×';
            topbar.appendChild(btnZoom);

            const stage = document.createElement('div');
            stage.className = 'glv-stage';
            main.appendChild(stage);

            const btnPrev = document.createElement('button');
            btnPrev.className = 'glv-nav glv-prev';
            btnPrev.type = 'button';
            btnPrev.textContent = '‹';
            stage.appendChild(btnPrev);

            const btnNext = document.createElement('button');
            btnNext.className = 'glv-nav glv-next';
            btnNext.type = 'button';
            btnNext.textContent = '›';
            stage.appendChild(btnNext);

            const imgWrap = document.createElement('div');
            imgWrap.className = 'glv-imgwrap';
            stage.appendChild(imgWrap);

            const img = document.createElement('img');
            img.className = 'glv-img';
            img.crossOrigin = 'anonymous';
            img.draggable = false;
            imgWrap.appendChild(img);

            const film = document.createElement('div');
            film.className = 'glv-film';
            main.appendChild(film);

            const side = document.createElement('aside');
            side.className = 'glv-side';
            shell.appendChild(side);

            const sideScroll = document.createElement('div');
            sideScroll.className = 'glv-side-scroll';
            side.appendChild(sideScroll);

            const makeSection = (title, variant) => {
                const sec = document.createElement('section');
                sec.className = 'glv-section';
                if (variant) sec.dataset.variant = variant;
                const h = document.createElement('div');
                h.className = 'glv-section-title';
                h.textContent = title;
                const body = document.createElement('div');
                body.className = 'glv-section-body';
                sec.appendChild(h);
                sec.appendChild(body);
                sideScroll.appendChild(sec);
                return body;
            };

            const basicBody = makeSection('基本信息', 'basic');
            const chipsBody = makeSection('拍摄参数', 'tools');
            const toneBody = makeSection('影调分析', 'tone');
            const toneKv = document.createElement('div');
            toneKv.className = 'glv-tone-kv';
            toneBody.appendChild(toneKv);
            const deviceBody = makeSection('设备信息', 'device');
            const modeBody = makeSection('拍摄模式', 'mode');
            const locationBody = makeSection('位置信息', 'location');
            const locationKv = document.createElement('div');
            locationBody.appendChild(locationKv);
            const locationMapWrap = document.createElement('div');
            locationMapWrap.className = 'glv-map-wrap';
            locationBody.appendChild(locationMapWrap);
            const histCanvas = document.createElement('canvas');
            histCanvas.className = 'glv-hist';
            const histWrap = document.createElement('div');
            histWrap.className = 'glv-hist-wrap';
            histWrap.appendChild(histCanvas);
            toneBody.appendChild(histWrap);

            let lastHistogram = null;

            const histResizeObserver = new ResizeObserver(() => {
                if (!lastHistogram) return;
                requestAnimationFrame(() => {
                    drawHistogram(histCanvas, lastHistogram);
                });
            });
            histResizeObserver.observe(histWrap);

            document.body.appendChild(root);

            const close = () => {
                if (!viewer) return;
                root.hidden = true;
                document.body.classList.remove('glv-lock');
                viewerIndex = -1;
            };

            const open = (idx) => {
                if (!loadedPhotos.length) return;
                viewerIndex = clamp(idx, 0, loadedPhotos.length - 1);
                document.body.classList.add('glv-lock');
                root.hidden = false;
                render();
            };

            const applyZoom = () => {
                img.style.transform = `translate3d(${viewerZoom.tx}px, ${viewerZoom.ty}px, 0) scale(${viewerZoom.scale})`;
                btnZoom.textContent = `${viewerZoom.scale.toFixed(1)}×`;
            };

            const resetZoom = () => {
                viewerZoom = { scale: 1, tx: 0, ty: 0, panning: false, px: 0, py: 0, baseTx: 0, baseTy: 0 };
                applyZoom();
            };

            const renderKeyValue = (container, rows) => {
                container.textContent = '';
                for (const row of rows) {
                    if (!row.value) continue;
                    const r = document.createElement('div');
                    r.className = 'glv-row';
                    const k = document.createElement('div');
                    k.className = 'glv-key';
                    k.textContent = row.key;
                    const v = document.createElement('div');
                    v.className = 'glv-val';
                    v.textContent = row.value;
                    r.appendChild(k);
                    r.appendChild(v);
                    container.appendChild(r);
                }
            };

            const renderTone = (tone) => {
                toneKv.textContent = '';

                const top = document.createElement('div');
                top.className = 'glv-row';
                const k0 = document.createElement('div');
                k0.className = 'glv-key';
                k0.textContent = '影调类型';
                const v0 = document.createElement('div');
                v0.className = 'glv-val';
                const mapType = {
                    normal: '正常',
                    'low-key': '低调',
                    'high-key': '高调',
                    'high-contrast': '高对比',
                };
                v0.textContent = mapType[tone?.toneType] || '正常';
                top.appendChild(k0);
                top.appendChild(v0);
                toneKv.appendChild(top);

                const grid = document.createElement('div');
                grid.className = 'glv-tone-metrics';

                const metric = (key, value) => {
                    const row = document.createElement('div');
                    row.className = 'glv-row';
                    const k = document.createElement('div');
                    k.className = 'glv-key';
                    k.textContent = key;
                    const v = document.createElement('div');
                    v.className = 'glv-val';
                    v.textContent = value;
                    row.appendChild(k);
                    row.appendChild(v);
                    return row;
                };

                const brightness = Number(tone?.brightness);
                const contrast = Number(tone?.contrast);
                const shadowRatio = Number(tone?.shadowRatio);
                const highlightRatio = Number(tone?.highlightRatio);
                grid.appendChild(metric('亮度', Number.isFinite(brightness) ? `${brightness}%` : '—'));
                grid.appendChild(metric('对比度', Number.isFinite(contrast) ? `${contrast}%` : '—'));
                grid.appendChild(metric('阴影占比', Number.isFinite(shadowRatio) ? `${Math.round(shadowRatio * 100)}%` : '—'));
                grid.appendChild(metric('高光占比', Number.isFinite(highlightRatio) ? `${Math.round(highlightRatio * 100)}%` : '—'));
                toneKv.appendChild(grid);
            };

            const renderBasic = (p) => {
                const fileName = p.name || p.path.split('/').slice(-1)[0] || '';
                const ext = getExt(p.path);
                const w = p._w;
                const h = p._h;
                const sizeText = w && h ? `${w} × ${h}` : '';
                const rows = [
                    { key: '文件名', value: fileName },
                    { key: '格式', value: ext },
                    { key: '尺寸', value: sizeText },
                    { key: '文件大小', value: p._bytes ? formatBytes(p._bytes) : '—' },
                    { key: '像素', value: w && h ? formatMp(w, h) : '—' },
                    { key: '色彩空间', value: p._color_space || '未校准' },
                    { key: '拍摄时间', value: formatDateTime(p.exif?.date_time) || '—' },
                    { key: '时区', value: formatUtcOffset() },
                ];
                renderKeyValue(basicBody, rows);
            };

            const formatPct = (ratio) => {
                const r = Number(ratio);
                if (!Number.isFinite(r)) return '—';
                return `${Math.round(Math.max(0, Math.min(1, r)) * 100)}%`;
            };

            const formatLat = (lat) => {
                const v = Number(lat);
                if (!Number.isFinite(v)) return '—';
                return `${Math.abs(v).toFixed(5)}° ${v >= 0 ? 'N' : 'S'}`;
            };

            const formatLon = (lon) => {
                const v = Number(lon);
                if (!Number.isFinite(v)) return '—';
                return `${Math.abs(v).toFixed(5)}° ${v >= 0 ? 'E' : 'W'}`;
            };

            const formatAlt = (alt) => {
                const v = Number(alt);
                if (!Number.isFinite(v)) return '—';
                return `${v.toFixed(4)}m`;
            };

            const colorSpaceText = (cs) => {
                const v = Number(cs);
                if (!Number.isFinite(v)) return '';
                if (v === 1) return 'sRGB';
                if (v === 65535) return '未校准';
                return `CS ${v}`;
            };

            const exposureProgramText = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return '';
                const map = {
                    0: '未定义',
                    1: '手动',
                    2: '程序自动',
                    3: '光圈优先',
                    4: '快门优先',
                    5: '创意程序',
                    6: '运动程序',
                    7: '人像模式',
                    8: '风景模式',
                };
                return map[n] || `EP ${n}`;
            };

            const sensingMethodText = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return '';
                const map = {
                    1: '未定义',
                    2: '一芯片彩色区域',
                    3: '两芯片彩色区域',
                    4: '三芯片彩色区域',
                    5: '彩色顺序区域',
                    7: '三线传感器',
                    8: '彩色顺序线性',
                };
                return map[n] || `SM ${n}`;
            };

            const formatEv = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return '';
                const s = n > 0 ? `+${n.toFixed(1)}` : n.toFixed(1);
                return `${s} EV`;
            };

            const exposureModeText = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return '';
                const map = { 0: '自动曝光', 1: '手动曝光', 2: '自动包围' };
                return map[n] || `EM ${n}`;
            };

            const meteringModeText = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return '';
                const map = {
                    0: '未知',
                    1: '平均测光',
                    2: '中央重点平均测光',
                    3: '点测光',
                    4: '分区测光',
                    5: '矩阵测光',
                    6: '局部测光',
                    255: '其他',
                };
                return map[n] || `MM ${n}`;
            };

            const whiteBalanceText = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return '';
                const map = { 0: '自动', 1: '手动' };
                return map[n] || `WB ${n}`;
            };

            const lightSourceText = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return '';
                const map = {
                    0: '未知',
                    1: '日光',
                    2: '荧光灯',
                    3: '钨丝灯',
                    4: '闪光灯',
                    9: '晴天',
                    10: '阴天',
                    11: '阴影',
                    12: '日光荧光灯',
                    13: '日白荧光灯',
                    14: '冷白荧光灯',
                    15: '白色荧光灯',
                    17: '标准灯A',
                    18: '标准灯B',
                    19: '标准灯C',
                    20: 'D55',
                    21: 'D65',
                    22: 'D75',
                    23: 'D50',
                    24: 'ISO工作室钨丝灯',
                    255: '其他',
                };
                return map[n] || `LS ${n}`;
            };

            const flashText = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return '';
                const fired = (n & 1) === 1;
                return fired ? '开' : '关';
            };

            const sceneCaptureTypeText = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return '';
                const map = { 0: '标准', 1: '风景', 2: '人像', 3: '夜景' };
                return map[n] || `SC ${n}`;
            };

            const formatFocal = (v) => {
                const n = Number(String(v || '').replace(/[a-zA-Z\s]/g, ''));
                if (!Number.isFinite(n) || n <= 0) return '';
                return `${n}mm`;
            };

            const maxApertureText = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n) || n <= 0) return '';
                const f = Math.pow(2, n / 2);
                if (!Number.isFinite(f) || f <= 0) return '';
                return `f/${f.toFixed(1)}`;
            };

            const renderDevice = (p) => {
                const extra = p._exif_extra;
                const rows = [
                    { key: '相机', value: [p.exif?.maker, p.exif?.model].filter(Boolean).join(' ') || '—' },
                    { key: '镜头', value: p.exif?.lens_model || '—' },
                    { key: '焦距', value: formatFocal(p.exif?.focal_length) || '—' },
                    { key: '35mm 等效', value: extra?.focalLength35mm ? `${extra.focalLength35mm}mm` : formatFocal(p.exif?.focal_length) || '—' },
                    { key: '最大光圈', value: maxApertureText(extra?.maxApertureValue) || (p.exif?.f_number ? `f/${String(p.exif.f_number).replace(/[^0-9.]/g, '')}` : '') || '—' },
                ];
                renderKeyValue(deviceBody, rows);
            };

            const renderMode = (p) => {
                const extra = p._exif_extra;
                const exposureBias = formatEv(extra?.exposureBiasValue);
                const brightnessValue = formatEv(extra?.brightnessValue);
                const shutterSpeedValue = formatEv(extra?.shutterSpeedValue);
                const apertureValue = formatEv(extra?.apertureValue);
                const rows = [
                    { key: '曝光程序', value: exposureProgramText(extra?.exposureProgram) || '—' },
                    { key: '曝光模式', value: exposureModeText(extra?.exposureMode) || '—' },
                    { key: '测光模式', value: meteringModeText(extra?.meteringMode) || '—' },
                    { key: '白平衡', value: whiteBalanceText(extra?.whiteBalance) || '—' },
                    { key: '闪光灯', value: flashText(extra?.flash) || '—' },
                    { key: '光源', value: lightSourceText(extra?.lightSource) || '—' },
                    { key: '感光方法', value: sensingMethodText(extra?.sensingMethod) || '—' },
                    { key: '场景捕获类型', value: sceneCaptureTypeText(extra?.sceneCaptureType) || '—' },
                    { key: '曝光补偿', value: exposureBias || '—' },
                    { key: '亮度值', value: brightnessValue || '—' },
                    { key: '快门速度值', value: shutterSpeedValue || '—' },
                    { key: '光圈值', value: apertureValue || '—' },
                ];
                // renderKeyValue(modeBody, rows);
            };

            const renderLocation = (p) => {
                const extra = p._exif_extra;
                const lat = extra?.gpsLat ?? p.loc?.lat;
                const lon = extra?.gpsLon ?? p.loc?.lon;
                const alt = extra?.gpsAlt;
                const latN = Number(lat);
                const lonN = Number(lon);
                const hasLoc = Number.isFinite(latN) && Number.isFinite(lonN);

                if (!hasLoc) {
                    renderKeyValue(locationKv, [{ key: '位置', value: '—' }]);
                    locationMapWrap.textContent = '';
                    return;
                }

                const rows = [
                    { key: '纬度', value: formatLat(latN) },
                    { key: '经度', value: formatLon(lonN) },
                    { key: '海拔', value: Number.isFinite(Number(alt)) ? formatAlt(alt) : '' },
                ];
                renderKeyValue(locationKv, rows);

                const href = `https://www.google.com/maps?q=${latN},${lonN}&z=15`;
                const imgSrc = `https://staticmap.openstreetmap.de/staticmap.php?center=${latN},${lonN}&zoom=15&size=640x360&scale=2&markers=${latN},${lonN},blue-pushpin`;
                locationMapWrap.textContent = '';
                const a = document.createElement('a');
                a.className = 'glv-map-card';
                a.href = href;
                a.target = '_blank';
                a.rel = 'noopener noreferrer';
                const im = document.createElement('img');
                im.alt = 'Map';
                im.loading = 'lazy';
                im.decoding = 'async';
                im.referrerPolicy = 'no-referrer';
                im.src = imgSrc;
                im.addEventListener('error', () => {
                    if (!a.isConnected) return;
                    a.textContent = `Google Maps (${latN.toFixed(5)}, ${lonN.toFixed(5)})`;
                }, { once: true });
                a.appendChild(im);
                locationMapWrap.appendChild(a);
            };

            const buildChipsNode = (exif) => {
                const wrap = document.createElement('div');
                wrap.className = 'glv-chips';
                for (const c of buildExifChips(exif)) {
                    const chip = document.createElement('div');
                    chip.className = 'gpro-chip';
                    const icon = createIconSvg(c.type);
                    icon.classList.add('gpro-chip-icon');
                    const label = document.createElement('span');
                    label.className = 'gpro-chip-label';
                    label.textContent = c.label;
                    chip.appendChild(icon);
                    chip.appendChild(label);
                    wrap.appendChild(chip);
                }
                return wrap;
            };

            const computeHistogram = () => {
                const result = calculateHistogramAndToneFromImage(img);
                if (!result) {
                    const ctx = histCanvas.getContext('2d');
                    if (ctx) {
                        const rect = histCanvas.getBoundingClientRect();
                        const w = rect.width || histCanvas.clientWidth || 0;
                        const h = rect.height || histCanvas.clientHeight || 0;
                        if (w && h) {
                            histCanvas.width = Math.round(w * (window.devicePixelRatio || 1));
                            histCanvas.height = Math.round(h * (window.devicePixelRatio || 1));
                            ctx.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
                            ctx.clearRect(0, 0, w, h);
                            ctx.fillStyle = 'rgba(255,255,255,0.08)';
                            ctx.fillRect(0, 0, w, h);
                        }
                    }
                    return;
                }

                const { histogram, tone } = result;
                lastHistogram = histogram;
                drawHistogram(histCanvas, histogram);

                if (viewerIndex >= 0) {
                    const p = loadedPhotos[viewerIndex];
                    renderTone(tone);
                    p._tone = tone;
                    p._hist = histogram;
                }
            };

            const renderFilm = (skipLoadMore) => {
                film.textContent = '';
                if (viewerIndex < 0) return;
                const start = clamp(viewerIndex - 12, 0, loadedPhotos.length - 1);
                const end = clamp(viewerIndex + 12, 0, loadedPhotos.length - 1);
                for (let i = start; i <= end; i++) {
                    const p = loadedPhotos[i];
                    const t = document.createElement('button');
                    t.type = 'button';
                    t.className = 'glv-thumb' + (i === viewerIndex ? ' active' : '');
                    const im = document.createElement('img');
                    im.draggable = false;
                    im.alt = p.name || '';
                    im.src = 'https://cdn.jsdelivr.net/gh/lfkdsk/gallery@thumbnail/' + p.path.replace(/\.\w+$/, '.webp');
                    t.appendChild(im);
                    t.addEventListener('click', () => open(i));
                    film.appendChild(t);
                }

                if (skipLoadMore) return;
                if (hasMore && !isFetching && end === loadedPhotos.length - 1) {
                    const before = loadedPhotos.length;
                    page += 1;
                    fetchData();
                    if (loadedPhotos.length !== before && viewerIndex >= 0) {
                        renderFilm(true);
                    }
                }
            };

            const render = () => {
                if (viewerIndex < 0) return;
                const p = loadedPhotos[viewerIndex];
                if (!p) return;
                const renderSeq = ++viewerRenderSeq;
                resetZoom();
                const thumbUrl = 'https://cdn.jsdelivr.net/gh/lfkdsk/gallery@thumbnail/' + p.path.replace(/\.\w+$/, '.webp');
                const fullUrl = 'https://cdn.jsdelivr.net/gh/lfkdsk/gallery@master/' + p.path;

                root.style.setProperty('--glv-bg', `url("${thumbUrl}")`);
                img.classList.add('glv-preview');
                img.src = thumbUrl;

                const pre = new Image();
                pre.crossOrigin = 'anonymous';
                pre.decoding = 'async';
                pre.onload = () => {
                    if (renderSeq !== viewerRenderSeq) return;
                    img.classList.remove('glv-preview');
                    img.src = fullUrl;
                    root.style.setProperty('--glv-bg', `url("${fullUrl}")`);
                    if (!p._w || !p._h) {
                        p._w = pre.naturalWidth;
                        p._h = pre.naturalHeight;
                    }
                    renderBasic(p);
                    renderDevice(p);
                    renderMode(p);
                    renderLocation(p);
                    if (!p._bytes) {
                        fetch(fullUrl, { method: 'HEAD' })
                            .then((r) => {
                                const len = r.headers.get('content-length');
                                if (len) return Number(len);
                                return 0;
                            })
                            .then((b) => {
                                if (renderSeq !== viewerRenderSeq) return;
                                if (b) p._bytes = b;
                                renderBasic(p);
                            })
                            .catch(() => {
                            });
                    }

                    if (!p._exif_extra && !p._exif_fetching) {
                        p._exif_fetching = true;
                        fetch(fullUrl, { headers: { Range: 'bytes=0-1048575' } })
                            .then((r) => r.arrayBuffer())
                            .then((buf) => parseJpegExif(buf))
                            .catch(() => {
                                return fetch(fullUrl)
                                    .then((r) => r.arrayBuffer())
                                    .then((buf) => parseJpegExif(buf))
                                    .catch(() => null);
                            })
                            .then((extra) => {
                                p._exif_fetching = false;
                                if (renderSeq !== viewerRenderSeq) return;
                                p._exif_extra = extra || {};
                                const cs = colorSpaceText(p._exif_extra.colorSpace);
                                if (cs) p._color_space = cs;
                                const sw = String(p._exif_extra.software || '').trim();
                                if (sw) p._software = sw;
                                renderBasic(p);
                                renderDevice(p);
                                renderMode(p);
                                renderLocation(p);
                            });
                    }
                };
                pre.src = fullUrl;

                renderBasic(p);

                renderDevice(p);
                renderMode(p);
                renderLocation(p);

                renderTone(null);

                chipsBody.textContent = '';
                const chipsNode = buildChipsNode(p.exif);
                if (chipsNode.childNodes.length) chipsBody.appendChild(chipsNode);

                renderFilm();
            };

            const nav = (dir) => {
                if (viewerIndex < 0) return;
                const next = viewerIndex + dir;
                if (next < 0) return;
                if (next >= loadedPhotos.length) {
                    if (hasMore && !isFetching) {
                        page += 1;
                        fetchData();
                        if (next < loadedPhotos.length) open(next);
                        renderFilm();
                    }
                    return;
                }
                open(next);
                if (next >= loadedPhotos.length - 6 && hasMore && !isFetching) {
                    page += 1;
                    fetchData();
                    renderFilm();
                }
            };

            btnPrev.addEventListener('click', () => nav(-1));
            btnNext.addEventListener('click', () => nav(1));
            btnClose.addEventListener('click', close);
            backdrop.addEventListener('click', close);

            btnZoom.addEventListener('click', () => {
                viewerZoom.scale = viewerZoom.scale < 1.5 ? 2 : viewerZoom.scale < 2.5 ? 3 : 1;
                if (viewerZoom.scale === 1) {
                    viewerZoom.tx = 0;
                    viewerZoom.ty = 0;
                }
                applyZoom();
            });

            img.addEventListener('load', () => {
                requestAnimationFrame(() => {
                    computeHistogram();
                });
            });

            imgWrap.addEventListener(
                'wheel',
                (e) => {
                    if (root.hidden) return;
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.2 : 0.2;
                    const next = clamp(viewerZoom.scale + delta, 1, 4);
                    viewerZoom.scale = next;
                    if (next === 1) {
                        viewerZoom.tx = 0;
                        viewerZoom.ty = 0;
                    }
                    applyZoom();
                },
                { passive: false }
            );

            imgWrap.addEventListener('dblclick', (e) => {
                if (root.hidden) return;
                e.preventDefault();
                viewerZoom.scale = viewerZoom.scale === 1 ? 2 : 1;
                if (viewerZoom.scale === 1) {
                    viewerZoom.tx = 0;
                    viewerZoom.ty = 0;
                }
                applyZoom();
            });

            imgWrap.addEventListener('pointerdown', (e) => {
                if (root.hidden) return;
                if (viewerZoom.scale <= 1) return;
                viewerZoom.panning = true;
                viewerZoom.px = e.clientX;
                viewerZoom.py = e.clientY;
                viewerZoom.baseTx = viewerZoom.tx;
                viewerZoom.baseTy = viewerZoom.ty;
                imgWrap.setPointerCapture(e.pointerId);
            });

            imgWrap.addEventListener('pointermove', (e) => {
                if (!viewerZoom.panning) return;
                viewerZoom.tx = viewerZoom.baseTx + (e.clientX - viewerZoom.px);
                viewerZoom.ty = viewerZoom.baseTy + (e.clientY - viewerZoom.py);
                applyZoom();
            });

            const endPan = (e) => {
                if (!viewerZoom.panning) return;
                viewerZoom.panning = false;
                try {
                    imgWrap.releasePointerCapture(e.pointerId);
                } catch (_) {
                }
            };
            imgWrap.addEventListener('pointerup', endPan);
            imgWrap.addEventListener('pointercancel', endPan);

            window.addEventListener('keydown', (e) => {
                if (root.hidden) return;
                if (e.key === 'Escape') {
                    e.preventDefault();
                    close();
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    nav(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    nav(1);
                }
            });

            viewer = { root, open, close, render };
            return viewer;
        }

        function createPhotoItem(photo) {
            const item = document.createElement("div");
            item.className = "gpro-item";
            item.setAttribute("data-date", photo.date);
            item.style.gridRowEnd = `span ${calcSpan(240, getMasonryMetrics().rowHeight, getMasonryMetrics().rowGap)}`;

            const a = document.createElement("a");
            a.href = 'https://cdn.jsdelivr.net/gh/lfkdsk/gallery@master/' + photo.path;
            a.addEventListener('click', (e) => {
                e.preventDefault();
                ensureViewer().open(photo._idx);
            });

            const img = document.createElement("img");
            img.className = "gpro-img lazy";
            img.alt = photo.name || "";
            img.src = PLACEHOLDER_IMG;
            img.setAttribute(
                "data-src",
                'https://cdn.jsdelivr.net/gh/lfkdsk/gallery@thumbnail/' + photo.path.replace(/\.\w+$/, ".webp")
            );
            const hover = document.createElement('div');
            hover.className = 'gpro-hover';

            const title = document.createElement('div');
            title.className = 'gpro-hover-title';
            title.textContent = photo.name || photo.path.split('/').slice(-1)[0] || '';

            const meta = document.createElement('div');
            meta.className = 'gpro-hover-meta';
            const extMatch = /\.([a-zA-Z0-9]+)$/.exec(photo.path || '');
            const ext = (extMatch ? extMatch[1] : '').toUpperCase();
            meta.textContent = `${ext || 'IMG'}`;

            const chipsWrap = document.createElement('div');
            chipsWrap.className = 'gpro-hover-chips';
            const chips = buildExifChips(photo.exif);
            for (const c of chips) {
                const chip = document.createElement('div');
                chip.className = 'gpro-chip';
                const icon = createIconSvg(c.type);
                icon.classList.add('gpro-chip-icon');
                const label = document.createElement('span');
                label.className = 'gpro-chip-label';
                label.textContent = c.label;
                chip.appendChild(icon);
                chip.appendChild(label);
                chipsWrap.appendChild(chip);
            }

            hover.appendChild(title);
            hover.appendChild(meta);
            if (chips.length) hover.appendChild(chipsWrap);

            img.addEventListener("load", () => {
                resizeMasonryItem(item);
                scheduleFloatingDateUpdate();
            });

            a.appendChild(img);
            item.appendChild(a);
            item.appendChild(hover);
            itemObserver.observe(item);
            return { item, img };
        }

        function buildPhotoQuery() {
            const whereParts = [];
            if (album !== null) {
                whereParts.push(
                    `Photo.dir_id = (SELECT Album.id FROM Album WHERE Album.dir = ${sqlString(album)})`
                );
            }
            if (maker !== null && maker !== "NONE") {
                whereParts.push(`EXIFData.maker = ${sqlString(maker)}`);
            }
            if (maker !== null && maker === "NONE") {
                whereParts.push("EXIFData.maker IS NULL");
            }
            if (lens_model !== null) {
                whereParts.push(`EXIFData.lens_model = ${sqlString(lens_model)}`);
            }
            if (focal_length !== null) {
                whereParts.push(`EXIFData.focal_length = ${sqlString(focal_length)}`);
            }
            if (country !== null && country !== "NONE") {
                whereParts.push(`Location.country = ${sqlString(country)}`);
            }
            if (country !== null && country === "NONE") {
                whereParts.push("Location.country = ''");
            }
            if (filter !== null && !historyToday) {
                whereParts.push(`DATE(EXIFData.date) = ${sqlString(filter)}`);
            }
            if (filter !== null && historyToday) {
                const md = String(filter).substring(5);
                whereParts.push(`substr(DATE(EXIFData.date), 6, 5) = ${sqlString(md)}`);
            }
            const whereClause = whereParts.length ? " WHERE " + whereParts.join(" AND ") : "";
            const orderDir = album !== null ? "ASC" : "DESC";
            const joinLocation = " LEFT JOIN Location ON Photo.location_id = Location.id";
            const limitClause = loadAll
                ? ";"
                : ` LIMIT ${pageSize} OFFSET ${(page - 1) * pageSize};`;

            return (
                "SELECT Photo.id, Photo.path, Photo.name, IFNULL(DATE(EXIFData.date), '###') AS photo_date, " +
                "EXIFData.focal_length, EXIFData.f_number, EXIFData.exposure_time, EXIFData.iso, EXIFData.maker, EXIFData.model, EXIFData.lens_model, EXIFData.date, " +
                "Location.lo, Location.hi, IFNULL(Location.country, '') " +
                "FROM Photo " +
                "LEFT JOIN EXIFData ON Photo.exif_data_id = EXIFData.id" +
                joinLocation +
                whereClause +
                ` ORDER BY CASE WHEN EXIFData.date IS NULL THEN 1 ELSE 0 END, EXIFData.date ${orderDir}, Photo.id ${orderDir}` +
                limitClause
            );
        }

        let loadMoreObserver = null;
        if (!loadAll) {
            loadMoreObserver = new IntersectionObserver(
                (entries) => {
                    if (!hasMore || isFetching) return;
                    if (entries[0].isIntersecting) {
                        page += 1;
                        fetchData();
                    }
                },
                { root: null, rootMargin: "0px", threshold: 0.1 }
            );
            loadMoreObserver.observe(sentinel);
        }

        function fetchData() {
            if (isFetching || !hasMore) return;
            isFetching = true;
            const query = buildPhotoQuery();
            const result = db.exec(query);
            if (!result.length || !result[0].values?.length) {
                hasMore = false;
                isFetching = false;
                loadMoreObserver?.disconnect();
                scheduleFloatingDateUpdate();
                return;
            }

            const newLazyImages = [];
            const rows = result[0].values;
            for (const row of rows) {
                const photo = {
                    id: row[0],
                    path: row[1],
                    name: row[2],
                    date: row[3],
                    exif: {
                        focal_length: row[4],
                        f_number: row[5],
                        exposure_time: row[6],
                        iso: row[7],
                        maker: row[8],
                        model: row[9],
                        lens_model: row[10],
                        date_time: row[11],
                    },
                    loc: {
                        lat: row[12],
                        lon: row[13],
                        country: row[14],
                    },
                };

                upsertPhoto(photo);

                if (historyToday) {
                    if (filter !== null && String(filter).substring(5) !== String(photo.date).substring(5)) {
                        continue;
                    }
                } else {
                    if (filter !== null && filter !== photo.date) {
                        continue;
                    }
                }

                const created = createPhotoItem(photo);
                masonry.appendChild(created.item);
                newLazyImages.push(created.img);
            }

            if (newLazyImages.length) {
                $(newLazyImages).lazyload();
            }
            resizeAllMasonryItems();
            isFetching = false;
        }

        window.addEventListener("scroll", scheduleFloatingDateUpdate, { passive: true });
        window.addEventListener("resize", () => {
            requestAnimationFrame(resizeAllMasonryItems);
        });
        fetchData();
    </script>
    <style>
        body {
            background-color: #0b0b0c;
        }

        html,
        body {
            height: 100%;
            margin: 0;
        }

        body.glv-lock {
            overflow: hidden;
        }

        .album-area {
            margin-top: 92px;
            padding-left: 12px;
            padding-right: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .floating-date {
            position: fixed;
            top: 76px;
            right: 16px;
            z-index: 10;
            padding: 8px 10px;
            border-radius: 999px;
            font-size: 13px;
            line-height: 1;
            letter-spacing: 0.04em;
            color: rgba(255, 255, 255, 0.92);
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(12px);
            opacity: 0;
            transform: translateY(-6px);
            pointer-events: none;
            transition: opacity 0.18s ease, transform 0.18s ease;
        }

        .floating-date.show {
            opacity: 1;
            transform: translateY(0);
        }

        .gpro-masonry {
            width: 100%;
            max-width: 2200px;
            grid-auto-rows: 6px;
            gap: 6px;
            padding-top: 0;
        }

        .gpro-item {
            width: 100%;
            overflow: hidden;
            border-radius: 0;
            position: relative;
        }

        .gpro-hover {
            position: absolute;
            inset: auto 0 0 0;
            padding: 10px 10px 10px 10px;
            color: rgba(255, 255, 255, 0.96);
            background: linear-gradient(180deg, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.72));
            opacity: 0;
            transform: translateY(6px);
            transition: opacity 0.18s ease, transform 0.18s ease;
            pointer-events: none;
        }

        .gpro-item:hover .gpro-hover {
            opacity: 1;
            transform: translateY(0);
        }

        .gpro-hover-title {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 0.01em;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.45);
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .gpro-hover-meta {
            margin-top: 4px;
            font-size: 12px;
            opacity: 0.9;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.45);
        }

        .gpro-hover-chips {
            margin-top: 8px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .gpro-chip {
            padding: 8px 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(10px);
            font-size: 12px;
            font-weight: 600;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .gpro-chip-icon {
            width: 16px;
            height: 16px;
            flex: 0 0 16px;
            stroke: rgba(255, 255, 255, 0.9);
            fill: none;
            stroke-width: 1.7;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .gpro-chip-icon text {
            fill: rgba(255, 255, 255, 0.9);
            stroke: none;
            font-size: 7px;
            font-weight: 700;
            letter-spacing: 0.04em;
            font-family: ui-sans-serif, system-ui, -apple-system;
        }

        .gpro-chip-label {
            line-height: 1;
            color: rgba(255, 255, 255, 0.84);
        }

        @media (max-width: 768px) {
            .gpro-hover-title {
                font-size: 14px;
            }

            .gpro-hover-meta {
                font-size: 11px;
            }

            .gpro-chip {
                font-size: 11px;
                padding: 7px 9px;
            }

            .gpro-chip-icon {
                width: 14px;
                height: 14px;
                flex-basis: 14px;
            }
        }

        .gpro-item a {
            display: block;
            width: 100%;
            height: 100%;
        }

        .gpro-img {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 0;
            background: rgba(255, 255, 255, 0.04);
            min-height: 80px;
            object-fit: cover;
        }

        .gpro-slogan {
            text-align: center;
            font-size: 36px;
            font-weight: 700;
            color: #3d4350;
        }

        .glv {
            position: fixed;
            inset: 0;
            z-index: 1000;
            display: block;
        }

        .glv[hidden] {
            display: none;
        }

        .glv-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        .glv-backdrop::before {
            content: '';
            position: absolute;
            inset: -40px;
            background-image: var(--glv-bg);
            background-size: cover;
            background-position: center;
            filter: blur(44px) saturate(1.25);
            transform: scale(1.06);
            opacity: 0.92;
        }

        .glv-backdrop::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(1200px 700px at 30% 40%, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.72));
        }

        .glv-shell {
            position: relative;
            width: 100vw;
            height: 100dvh;
            display: grid;
            grid-template-columns: 1fr 380px;
            grid-template-rows: 1fr;
            background: rgba(12, 12, 13, 0.82);
            border: 0;
            border-radius: 0;
            overflow: hidden;
            min-height: 0;
        }

        .glv-main {
            display: flex;
            flex-direction: column;
            min-width: 0;
            min-height: 0;
            position: relative;
            height: 100%;
            overflow: hidden;
        }

        .glv-topbar {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 6px;
            padding: 6px;
            flex: 0 0 auto;
        }

        .glv-btn {
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(0, 0, 0, 0.35);
            color: rgba(255, 255, 255, 0.92);
            border-radius: 10px;
            height: 30px;
            padding: 0 10px;
            font-size: 13px;
            font-weight: 650;
        }

        .glv-close {
            width: 34px;
            padding: 0;
            font-size: 18px;
            line-height: 1;
        }

        .glv-stage {
            position: relative;
            display: grid;
            place-items: center;
            overflow: hidden;
            z-index: 1;
            min-height: 0;
            flex: 1 1 auto;
        }

        .glv-stage::before {
            content: '';
            position: absolute;
            inset: -20px;
            background-image: var(--glv-bg);
            background-size: cover;
            background-position: center;
            filter: blur(26px) saturate(1.15);
            transform: scale(1.04);
            opacity: 0.55;
            z-index: 0;
        }

        .glv-stage::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(900px 520px at 50% 45%, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.52));
            z-index: 0;
        }

        .glv-imgwrap {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            min-height: 0;
            position: relative;
            z-index: 1;
            overflow: hidden;
            padding: 12px;
            box-sizing: border-box;
        }

        .glv-img {
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            image-orientation: from-image;
            transform-origin: center;
            will-change: transform;
            user-select: none;
            transition: filter 0.18s ease, opacity 0.18s ease;
            box-shadow: 0 18px 70px rgba(0, 0, 0, 0.55);
            outline: 1px solid rgba(255, 255, 255, 0.08);
            display: block;
        }

        .glv-img.glv-preview {
            filter: blur(12px) saturate(1.1);
            opacity: 0.98;
        }

        .glv-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 42px;
            height: 42px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(0, 0, 0, 0.28);
            color: rgba(255, 255, 255, 0.92);
            font-size: 26px;
            line-height: 1;
            z-index: 2;
        }

        .glv-prev {
            left: 12px;
        }

        .glv-next {
            right: 12px;
        }

        .glv-film {
            display: flex;
            gap: 0;
            padding: 0;
            overflow-x: auto;
            align-items: center;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(0, 0, 0, 0.88);
            backdrop-filter: blur(16px);
            position: relative;
            z-index: 3;
            box-shadow: 0 -16px 40px rgba(0, 0, 0, 0.65);
            flex: 0 0 auto;
            height: 96px;
        }

        .glv-thumb {
            width: 72px;
            height: 72px;
            border-radius: 0;
            overflow: hidden;
            border: 0;
            background: transparent;
            padding: 0;
            flex: 0 0 auto;
        }

        .glv-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            filter: grayscale(1);
            transition: filter 0.16s ease;
        }

        .glv-thumb.active img {
            filter: none;
        }

        .glv-thumb:not(.active):hover img {
            filter: none;
        }

        .glv-side {
            display: flex;
            flex-direction: column;
            border-left: 0;
            background: rgba(140, 140, 140, 0.14);
            backdrop-filter: blur(26px);
            min-width: 0;
            overflow: hidden;
            height: 100%;
            min-height: 0;
        }

        .glv-side-scroll {
            overflow: auto;
            padding: 14px;
        }

        .glv-section {
            border: 0;
            background: transparent;
            backdrop-filter: none;
            border-radius: 0;
            overflow: visible;
        }

        .glv-section + .glv-section {
            margin-top: 8px;
        }

        .glv-section-title {
            padding: 0;
            font-size: 13px;
            font-weight: 750;
            color: rgba(255, 255, 255, 0.84);
            border-bottom: 0;
            background: transparent;
        }

        .glv-section-body {
            padding: 6px 0 0;
        }

        .glv-row {
            display: grid;
            grid-template-columns: 96px 1fr;
            gap: 8px;
            padding: 3px 0;
            border-bottom: 0;
        }

        .glv-row:last-child {
            border-bottom: 0;
        }

        .glv-key {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
        }

        .glv-val {
            color: rgba(255, 255, 255, 0.92);
            font-size: 14px;
            word-break: break-word;
        }

        .glv-section[data-variant='basic'] .glv-row {
            grid-template-columns: 140px 1fr;
        }

        .glv-section[data-variant='basic'] .glv-key {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.01em;
        }

        .glv-section[data-variant='basic'] .glv-val {
            font-size: 14px;
            font-weight: 600;
            text-align: right;
            letter-spacing: 0.01em;
        }

        .glv-section[data-variant='basic'] .glv-section-title {
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.78);
        }

        .glv-section[data-variant='basic'] .glv-section-body {
            padding-top: 10px;
        }

        .glv-section[data-variant='tools'] .gpro-chip-label {
            color: rgba(255, 255, 255, 0.92);
        }

        .glv-chips {
            margin-top: 8px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .glv-hist-wrap {
            width: 100%;
            height: 128px;
            margin-top: 8px;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .glv-hist {
            width: 100%;
            height: 100%;
            display: block;
            border: 0;
            background: transparent;
            position: relative;
            z-index: 0;
        }

        .glv-map-wrap {
            margin-top: 10px;
        }

        .glv-side .glv-map-card {
            display: block;
            width: 100%;
            height: 120px;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(28, 28, 30, 0.95);
            color: rgba(255, 255, 255, 0.9);
            text-decoration: none;
            line-height: 120px;
            text-align: center;
            font-size: 12px;
        }

        .glv-side .glv-map-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .glv-section[data-variant='tone'] .glv-val {
            text-align: right;
        }

        .glv-section[data-variant='device'] .glv-val {
            text-align: right;
        }

        .glv-tone-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            column-gap: 14px;
        }

        .glv-tone-metrics .glv-row {
            padding: 2px 0;
        }

        @media (max-width: 900px) {
            .glv-shell {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr;
                width: 100vw;
                height: 100vh;
            }

            .glv-side {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .gpro-slogan {
                font-size: 28px;
            }

            .content-area {
                margin-top: 80px;
            }

            .floating-date {
                top: 66px;
                right: 12px;
            }

            .album-area {
                padding-left: 8px;
                padding-right: 8px;
            }

            .gpro-masonry {
                gap: 4px;
                grid-auto-rows: 5px;
            }
        }
    </style>
</section>

  <!-- Footer -->
  <!-- Footer -->
<footer class="itp-footer text-center">
  <section class="footer-info">
    照片集 &copy; 2017 - 2026
    
    
    
    <span> / Template</span>
    <a href="https://github.com/lfkdsk/album_template" target="_blank">Type
    </a>
  </section>
  
    <section class="footer-logo">
      <a href="https://gallery.lfkdsk.org/" target="_blank">
        <img width="80px" height="80px" style="padding-top: 12px; display: block; margin: 0 auto;" src="https://github.com/lfkdsk/picx-images-hosting/raw/master/20230817/tripper2white.2pbuwaqvndu0.webp" alt="footer logo"></a>
    </section>
  
</footer>

  <!-- After footer scripts -->
  <!-- fancybox -->

<link rel="stylesheet" href="" />
<script src="/js/fancybox.umd.js" defer></script>

<!-- mdui -->

<!-- busuanzi -->

<!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script> -->

<!-- highlightjs -->


<script src="/js/highlight.min.js"></script>

<script>window.addEventListener('load', () => {
  hljs.highlightAll(); // initialize highlighting
});</script>
<script>
  $("pre.code").each(function() {
    $(this).html("<ol><li>" + $(this).html().replace(/\n/g, "\n</li><li>") + "\n</li></ol>");
  });
</script>



<script src="/js/app.js"></script>



<!--

<script src="/js/canvas2image.js"></script>


<script src="/js/shareimg.js"></script>

<script src="https://html2canvas.hertzen.com/dist/html2canvas.js" defer></script>
-->
<!--lazyload-->


<script src="/js/lazyload.js"></script>


<!--PJAX-->
<!--Pjax from https://github.com/MoOx/pjax-->

<!--<script src="https://cdn.jsdelivr.net/npm/pjax/pjax.js"></script>-->
<!---->
<!---->
<!---->
<!---->
<!--首页键盘快捷键-->

  <style>
  :root {
    --main-color: #71AFDD;
    --sub-color: #6CD9CE;
    --main-black: #222831;
  }
</style>
</body>




</html>
